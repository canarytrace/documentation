---
sidebar_position: 1
description: Description of the metrics
title: Web Performance
tags:
  - webPerf
  - glossary
---

:::info
Web performance, or website performance, generally refers to the speed at which web pages load and display in a user's browser. It's a crucial aspect of user experience that can significantly impact a website's traffic and conversion rates.

Performance metrics are specific measurements that allow us to quantify and track website performance. These metrics can include factors such as page load time, Time to First Byte (TTFB), and Time to Interactive (TTI) and more.

All of these key metrics are collected by Canarytrace, making it an effective tool for monitoring and improving web performance to provide a high-quality user experience.

:::

## Core Web Vitals

Core Web Vitals are the subset of Web Vitals that apply to all web pages, should be measured by all site owners, and will be surfaced across all Google tools. Each of the Core Web Vitals represents a distinct facet of the user experience, is measurable in the field, and reflects the real-world experience of a critical user-centric outcome.

<div style={{ display: 'flex', justifyContent: 'space-between' }}>
  <img src='https://web-dev.imgix.net/image/tcFciHGuF3MxnTr1y5ue01OGLBn2/ZZU8Z7TMKXmzZT2mCjJU.svg' alt='LCP' style={{ width: '30%' }} />
  <img src='https://web-dev.imgix.net/image/tcFciHGuF3MxnTr1y5ue01OGLBn2/iHYrrXKe4QRcb2uu8eV8.svg' alt='FID' style={{ width: '30%' }} />
  <img src='https://web-dev.imgix.net/image/tcFciHGuF3MxnTr1y5ue01OGLBn2/dgpDFckbHwwOKdIGDa3N.svg' alt='CLS' style={{ width: '30%' }} />
</div>

- [Largest Contentful Paint (LCP)](./webperf#lcp): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading.
- [First Input Delay (FID)](./webperf#fid): measures interactivity. To provide a good user experience, pages should have a FID of 100 milliseconds or less.
- [Cumulative Layout Shift (CLS)](./webperf#cls): measures visual stability. To provide a good user experience, pages should maintain a CLS of 0.1. or less.

More information about [Core Web Vitals](https://web.dev/vitals/#core-web-vitals)

### LCP

Largest Contentful Paint (LCP) is an important, [stable](https://web.dev/vitals/#stable) Core Web Vital metric for measuring perceived load speed because it marks the point in the page load timeline when the page's main content has likely loaded—a fast LCP helps reassure the user that the page is useful.

Largest Contentful Paint (LCP) is a metric that measures the time from page load to the moment when the largest visual element ([image or text block](https://web.dev/lcp/#what-elements-are-considered)) on the page is displayed. Deterioration of this metric can be caused by several factors:

- **Slow server times:** The length of server response times can greatly affect LCP. If the server takes a long time to process and deliver resources, it can delay the display of content.

- **Third-party resource usage:** Unoptimized or redundant third-party resources can cause a delay in the display of the main content.

- **Client-side rendering (CSR):** In CSR, content is generated by JavaScript in the browser, which can cause a delay in displaying the main content if the JavaScript is heavy or inefficient.

- **Slow network times:** If the network connection is slow, it may take longer for the largest element on the page to load and display.

- **Unoptimized and large images:** Large or unoptimized images can take a long time to load and display, which can cause a delay in LCP.

Improving the LCP metric often involves optimizing server and network, managing third-party resources, reconsidering rendering strategy (e.g., switching to server-side rendering (SSR) or static site generation (SSG) instead of CSR), and optimizing images and other large media.

More information abtout [LCP](https://web.dev/lcp/)

### FID

FID measures the time from when a user first interacts with a page (that is, when they click a link, tap on a button, or use a custom, JavaScript-powered control) to the time when the browser is actually able to begin processing event handlers in response to that interaction.

:::tip
First Input Delay (FID) is the [stable](https://web.dev/vitals/#stable) Core Web Vital metric for measuring load responsiveness because it quantifies the experience users feel when trying to interact with unresponsive pages—a low FID helps ensure that the page is usable. FID will be [replaced by Interaction to Next Paint (INP)](https://web.dev/inp-cwv/) as a Core Web Vital in March 2024.
:::

#### Factors That Can Degrade the FID Metric

- **Heavy JavaScript Operations:** If your website has a lot of JavaScript to process, the browser may be busy and can't respond to user input right away. While JavaScript is being processed, the browser may be in a "blocked state".

- **Long Tasks:** If you have long tasks in JavaScript (tasks that take longer than 50 ms), they can block the main thread and cause a delay in response to user input.

- **Insufficient Optimization:** Unoptimized code, especially JavaScript and CSS, can also cause a higher FID. This can include inefficient algorithms, unnecessary code, or unused code.

- **Unoptimized Third-Party Resources:** Third-party resources, such as ads, analytic scripts, or embedded content, can cause high FID if they are not properly managed.

- **Insufficient Use of Web Workers:** Web Workers allow JavaScript to run in the background on a separate thread, off the main browser thread. Not taking advantage of this can lead to a higher FID, as it can free up the main thread for quicker response to user inputs.

Optimization for better FID often involves improving code efficiency, limiting the amount of JavaScript sent to the browser, breaking up long tasks into smaller ones that the browser can handle more easily, and managing third-party resources.

More information about [FID](https://web.dev/fid/)


### INP

INP is an experimental user-centric metric that evaluates response. INP tracks the response of all or most of the interactions that a user has made with a page. A low INP means that the page is able to quickly respond to all or most user interactions.
The task of INP is not to measure all interactions (e.g., network loading, UI updates from other async operations), but to block further painting. In other words, the time from when the user initiated the interaction to the rendering of the next frame.

#### What's in an interaction?

![What is an interaction](https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/Ng0j5yaGYZX9Bm3VQ70c.svg)
The life of an interaction. An input delay occurs until event handlers begin running, which may be caused by factors such as long tasks on the main thread. The interaction's event handlers then run, and a delay occurs before the next frame is presented.


#### Recommended INP Values

- **Good:** INP less than 200 milliseconds.
- **Needs Improvement:** INP between 200 and 500 milliseconds.
- **Poor:** INP greater than 300 milliseconds.

#### Recommendations for INP Optimization

Interactivity is a key part of user experience, and optimizing for Interactivity and Navigation Profiling (INP) can greatly improve the perceived performance of your web page or application. Here are some recommendations:

- **Minimize JavaScript Execution:** Reducing the time spent executing JavaScript can greatly improve INP. This could be achieved through various strategies, such as reducing the size of JavaScript files, deferring non-critical JavaScript until after the first load, or running scripts asynchronously.

- **Optimize Main Thread Usage:** The browser's main thread is responsible for most rendering tasks as well as parsing and executing JavaScript. Long tasks can block this thread, making your page unresponsive. Identifying and optimizing these tasks can improve INP.

- **Code Splitting:** This technique allows you to split your code into smaller chunks which can then be loaded on demand. This can help in reducing the amount of code that needs to be parsed and executed at once, improving INP.

- **Use Web Workers for Background Tasks:** Web Workers allow you to run JavaScript in the background on a separate thread. This can be used to offload non-UI tasks from the main thread, improving INP.

- **Optimize Resource Loading:** Prioritize loading of critical resources and defer non-critical ones. This includes optimizing your network requests, using efficient loading strategies like lazy loading, and implementing effective caching strategies.

- **Listen to User Interactions Passively:** In JavaScript, you can set up event listeners that either block the main thread until they finish running, or are set up as "passive" to run without blocking. Whenever possible, set your event listeners to be passive to improve INP.

As always, the best strategy can depend on the specifics of your webpage or application. Regular monitoring and performance profiling can help you quickly identify and address any issues affecting your INP.

- What is the difference between FID and INP? https://web.dev/inp/#how-is-inp-different-from-first-input-delay-fid

More information about [INP](https://web.dev/inp/)

### CLS

Cumulative Layout Shift (CLS) is a [stable](https://web.dev/user-centric-performance-metrics/#types-of-metrics) Core Web Vital metric. It is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts—a low CLS helps ensure that the page is [delightful](https://web.dev/user-centric-performance-metrics/#questions).

More information about [CLS](https://web.dev/cls/).

## Metrics

### FPS

A frame rate is the speed at which a browser can recalculate, layout, and paint content on the display. A lower Frames Per Second (FPS) rate indicates issues with the main thread and performance problems on the web page, such as long-running [Long Task](./webperf#longtask) due to complex JavaScript.

#### Recommendations for FPS Optimization

Optimizing Frames Per Second (FPS) is crucial for a smooth and responsive performance of a web page or application. Here are some recommendations:

- **Minimize Complex Computations:** If your application is performing complex calculations or data processing, try to minimize or perform them asynchronously to avoid blocking the main thread.

- **Avoid Redundant Rendering:** Not every state or data change requires a re-render. Use techniques like memoization to improve performance and reduce unnecessary renders.

- **Optimize CSS and JavaScript:** Unnecessarily complex CSS or JavaScript can cause the browser to do more work, potentially leading to lower FPS. Optimize your code and minimize the use of demanding CSS properties, like complex transitions or animations.

- **Leverage Hardware Acceleration:** Some CSS properties, like transforms and opacity, can be hardware-accelerated. This can result in improved FPS.

- **Throttling and Debouncing:** These techniques can be helpful in limiting the number of tasks generated by events like scrolling or browser window resizing, improving FPS.

- **Use Request Animation Frame for Animations:** Instead of setting an interval or timer for animations, use requestAnimationFrame. This function is optimized for the browser and allows for smoother animations.

- **Monitoring and Profiling:** Use tools like Chrome DevTools to monitor and profile your application's performance, helping to identify areas that require optimization.

Remember, the right strategy depends on the specific scenario and the type of application you are building. Regular monitoring and testing of your application's performance can be helpful in quickly identifying and addressing performance issues.

- [Analyze frames per seconds](https://developer.chrome.com/docs/devtools/performance/#analyze_frames_per_second) in your browser.


### Long Task

As a page loads or a user interacts with an application, the browser assigns tasks to the User Interface (UI) thread for processing. If any task takes longer than 50ms, the page will appear choppy, and typing into an input field will not be smooth.

#### Long tasks exceeding 50ms cause problems such as:

- Delayed Time to Interactive (TTI).
- High/variable input latency.
- High/variable event handling latency.
- Jank in animations and scrolling.

#### A long task is any uninterrupted period when the main UI thread is busy for 50ms or more. Common examples include:

- Long-running event handlers.
- Expensive reflows and other re-rendering tasks.
- Work that the browser performs between different event loop rotations that exceed 50ms.

#### Recommendations for Long Task Optimization

- **Task Splitting:** Complex computational tasks often result in long tasks. If possible, try to break these tasks down into smaller, less demanding ones.

- **Asynchronous Processing:** Some tasks can be executed asynchronously. This prevents the blocking of the main thread, allowing the page to respond to user actions while the task is underway.

- **Web Workers:** Web Workers are scripts that run in the background without blocking the main webpage thread. They can be helpful in executing demanding tasks without affecting page performance.

- **Code Optimization:** Try to avoid complex and demanding operations where possible. Optimizing JavaScript and CSS can help reduce task processing time.

- **Throttling and Debouncing:** These techniques can help limit the number of tasks generated by events such as scrolling or browser window resizing.

- **Performance Monitoring Tools:** Tools like Chrome DevTools can help identify long tasks and provide suggestions for performance improvements.

Remember, the right strategy depends on the specific scenario and the types of tasks you are handling.